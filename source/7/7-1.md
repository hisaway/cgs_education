### [目次に戻る](../../README.md)

# 固定長配列
以前，「ファイルを読み込んで構造体にデータを格納する」という処理をしたことがありますね．  
そのとき，「一度ファイルを読み込んでデータのサイズを把握して構造体のメモリを確保した後，再度ファイルを読み込んで入力データを構造体に格納する」という処理になっていました．  

あまりスマートではありませんね．．．

配列を動的に確保したとしても，その後に**配列の長さは変わりません．**   

このような配列を**固定長配列**といいます．  
# 可変長配列
データのサイズがわからなくても，データを配列に保存することができれば便利ですね．  
なので，以下のようなロジックを使って，**可変長配列**を作ってみます．  

1. ポインタ変数を定義する
3. 新たにデータを入力する必要がある場合，元のデータを一時的に別の変数に保存して，新たに入力データサイズ分とすでに入っているデータサイズ分のメモリを確保する
4. 一時的に保存したデータと入力データを合わせて，データを保存する．
5. 一時的に保存したデータを削除する
4. 2~5を繰り返す．

上記のロジックをうまく関数化すれば，最初からデータのサイズを知らなくても，データを保存することができます．  

このように，用途に合わせて長さが変わる配列を**可変長配列**といいます．

# `vector<T>`クラス
可変長配列は汎用的に使用されるので，標準機能として組み込まれています．

```vector:cpp
#include <vector>

using namespace std;

int main(){
	
	// int型の可変長配列を宣言
	vector<int> nums;
	
	// int型のデータを追加する
	nums.push_back(1);
	nums.push_back(2);
	nums.push_back(3);
	
	// 入力されたデータを操作する
	for(int i = 0; i < nums.size(); ++i){
		cout << nums[i] << endl;
	}
	
	// 使用しなくなったデータを削除する
	nums.clear();
	nums.shrink_to_fit();
	
	return 0;
}

```

# Standard Template Library
`vector<T>`を代表としたさまざまなテンプレートクラスがあります．これらを`STL:Standard Template Library`と呼びます．  
上記の可変長配列以外にも**連想配列**`map<T, U>`など使いこなせれば，より良いコードがかけるようになるかと思います．

# 演習課題
`vector<T>`を使用して，以前の「ファイルから構造体にデータを入力する」プログラムを「ファイルから読み込んでクラスに保存する」という仕様に変更して，スマートな（無駄のない）プログラムを作成してください．  

以前の課題は[こちら](../3/3.md#追加演習)のページの追加演習です

| [](.md)_______________________________ |[章目次](7.md)| _______________________________[](.md) |
|:---|:---:|---:|

### [教材TOP](../../README.md)
　