# Program 4_2 : 20181009
担当：久江 (GitHub: @yukq1, Qiita: @hisaway)

# 動的配列
[前回の演習](4_1.md)で動的配列について調べましたか？

こんな構文でしたね．
```cpp
int size = 10;
int* array;
array = (int*)malloc(sizeof(int)*size);
```

この構文は，ある領域から(int型のサイズ * 任意の領域分)あらかじめメモリを確保しておくというコードです．

なぜこんなことをしなければならないかというと，コンピュータは配列外にアクセスした時に自動でメモリを再確保するということをしてくれないからです．

これは配列の参照を渡す際も同じです．

# 配列の参照渡し
配列を関数に渡すときは「配列名」をそのまま関数に渡します．

```cpp
void do_array(int* array){
  // process...
}

int main(){
  int num[3] = {1, 1, 2};
  
  do_array(num);
  printf("%p", num); //配列のアドレスを表示
}
```

このままでは，呼び出した関数の先で配列の数がわかりませんね？  
対応としては2つあります．

1. あらかじめ配列のサイズを引数として一緒に渡す (今回はこちらの方法)
1. 呼び出した関数の先で，配列のサイズを計算する（調べてみましょう）



# 演習
上記のコードを元に以下の機能を満たす関数を実装してみましょう．

- 引数として，配列を参照，配列のサイズを値として受け取る
- 受け取った配列の各要素を2乗する
- 関数名もちゃんと考えましょう．


イメージはこんな感じです．

```cpp
void func(int* array, int size){
  // arrayの要素を2乗する
} 

int main(){
  int array[4] = {1, 2, 3, 4}; // できれば動的配列に． 
  func(array, 4);
  
  int i = 0;
  for(i = 0; i < 4; i++){
    printf("%d ", array[i]);
  }
}
```

### [次へ](4_3.md)





